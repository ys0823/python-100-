#----------------------------------------
#题目：使用python标准算法实现数组全排列。、
#要求：从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，
#叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。
#2018-8-31
'''
递减进位制数法的中介数进位不频繁，求下一个排列在不进位的情况下很容易。
这就启发我们，能不能设计一种算法，下一个排列总是上一个排列某相邻两位对换得到的。
递减进位制数字的换位是单向的，从右向左，而邻位对换法的换位是双向的。 这个算法可描述如下：
对1—n-1的每一个偶排列，n从右到左插入n个空档(包括两端)，生成1—n的n个排列。
对1—n-1的每一个奇排列，n从左到右插入n个空档，生成1—n的n个排列。
对[2,n]的每个数字都是如此。
839647521
字典序法 递增进位制法 递减进位制法 邻位对换法
下一个 839651247 849617523 893647521 836947521
中介数 72642321↑ 67342221↑ 12224376↓ 10121372↓
序 号 297191 279905 340989 203393
'''
#----------------------------------------
def Mideng(li):
    if (type(li) != list):
        return
    if (len(li) == 1):
        return [li]
    result = []
    for i in range(0,len(li[:])):
        bak = li[:]
        head = bak.pop(i) #移除i所在位置的值
        for j in Mideng(bak):
            j.insert(0, head) #将head的值添加到指定位置处,这里是第一个元素的位置
            result.append(j)
    return result

def MM(n):
    if (type(n) != int or n<2):
        return
    return Mideng(list(range(1,n)))
print(MM(6))
